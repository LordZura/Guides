#!/usr/bin/env python3
"""
create_files_fixed.py

Usage:
  python create_files_fixed.py --list-file files.txt --base-dir Guides
  cat files.txt | python create_files_fixed.py --base-dir Guides

Options:
  --list-file / -l   : text file with one path per line (optional if piping)
  --base-dir  / -b   : base directory where files will be created (default: .)
  --dry-run          : show what would be done but don't write files
  --overwrite        : overwrite existing files
  --verbose / -v     : print extra information
"""
import argparse
from pathlib import Path
import sys
import re

# Templates: don't rely on Python format() for safety â€” use literal "{name}" placeholder only.
TEMPLATES = {
    "package.json": '{\n  "name": "{name}",\n  "version": "0.0.1",\n  "private": true\n}\n',
    "vite.config.ts": "// vite.config.ts (placeholder)\n",
    "index.html": "<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <title>{name}</title>\n</head>\n<body>\n</body>\n</html>\n",
    "tsconfig.json": '{\n  "compilerOptions": {\n    "target": "ESNext",\n    "module": "ESNext"\n  }\n}\n',
    "postcss.config.cjs": "module.exports = { plugins: [] }\n",
    "tailwind.config.cjs": "module.exports = { content: [], theme: { extend: {} }, plugins: [] }\n",
    ".env.example": "# Example env file\n# KEY=value\n",
    "README.md": "# {name}\n\nProject generated by create_files_fixed.py\n",
    # generic extension templates
    ".html": "<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n</head>\n<body>\n</body>\n</html>\n",
    ".md": "# {name}\n",
    ".json": "{\n\n}\n",
    ".ts": "// TypeScript file: {name}\n",
    ".tsx": "import React from 'react'\n\nexport default function {name}() {\n  return <div>{name}</div>\n}\n",
    ".js": "// JavaScript file: {name}\n",
    ".css": "/* styles for {name} */\n",
    ".cjs": "// CommonJS config / script\n",
}

def pick_template(path: Path) -> str:
    """Return template content for a path. Replace only the literal '{name}' placeholder."""
    # exact filename match first
    name_key = path.name
    if name_key in TEMPLATES:
        return TEMPLATES[name_key].replace("{name}", path.stem)

    # try to match combined suffixes (like .config.js) or full suffix sequence
    suffixes = "".join(path.suffixes)  # e.g. ".config.js" or ".tsx"
    if suffixes in TEMPLATES:
        return TEMPLATES[suffixes].replace("{name}", path.stem)

    # match last suffix
    ext = path.suffix
    if ext in TEMPLATES:
        return TEMPLATES[ext].replace("{name}", path.stem)

    # heuristics / sensible defaults
    if ext in (".ts", ".tsx", ".js", ".jsx"):
        return f"// {path.name}\n\n"
    if ext in (".css", ".scss", ".sass"):
        return f"/* {path.name} */\n"
    if ext == ".json":
        return "{\n\n}\n"
    if ext == ".html":
        return "<!doctype html>\n"
    return ""  # empty file if nothing suitable

def normalize_line(line: str) -> str:
    """Strip bullets, numbering, outer quotes, and inline comments after '#'. Return cleaned path or ''."""
    line = line.strip()
    if not line:
        return ""
    # remove bullets like "- " or "* " or numbering "1. "
    line = re.sub(r'^\s*[-*+]\s+', '', line)
    line = re.sub(r'^\s*\d+\.\s+', '', line)
    # strip outer quotes/backticks
    line = line.strip('`"\'')
    # remove inline comment starting with ' #' (but allow paths containing '#')
    # use first '#' preceded by a space or at line start after path; common in lists
    if ' #' in line:
        line = line.split(' #', 1)[0].rstrip()
    # also split on ' #' or '\t#'
    return line

def read_paths_from_file(filepath: Path):
    with filepath.open("r", encoding="utf-8") as f:
        for raw in f:
            s = normalize_line(raw)
            if s:
                yield s

def read_paths_from_stdin():
    for raw in sys.stdin:
        s = normalize_line(raw)
        if s:
            yield s

def main():
    p = argparse.ArgumentParser(description="Create files and directories from a list")
    p.add_argument("--list-file", "-l", type=Path, help="Text file with one path per line")
    p.add_argument("--base-dir", "-b", type=Path, default=Path("."), help="Base directory")
    p.add_argument("--dry-run", action="store_true", help="Don't create; just show")
    p.add_argument("--overwrite", action="store_true", help="Overwrite existing files")
    p.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    args = p.parse_args()

    if not args.list_file and sys.stdin.isatty():
        p.error("Provide --list-file or pipe paths via stdin")

    if args.list_file:
        path_iter = read_paths_from_file(args.list_file)
    else:
        path_iter = read_paths_from_stdin()

    created = []
    skipped = []
    failed = []

    base_resolved = args.base_dir.resolve()

    for rel in path_iter:
        # strip trailing comments after first ' #' or '#'
        if '#' in rel and not rel.startswith('#'):
            # keep cases where path legitimately starts with '#'; otherwise split
            # prefer splitting by ' #' (space + hash) first
            if ' #' in rel:
                rel = rel.split(' #', 1)[0].strip()
            else:
                # as fallback, don't split aggressively
                pass

        if not rel:
            continue

        rel_path = Path(rel)
        target = (base_resolved / rel_path).resolve()
        parent = target.parent

        try:
            if args.dry_run:
                print(f"[DRY] Would create directories: {parent}")
                print(f"[DRY] Would create file: {target}")
                created.append(str(target))
                continue

            # Make directories
            if not parent.exists():
                parent.mkdir(parents=True, exist_ok=True)
                if args.verbose:
                    print(f"mkdir: {parent}")

            if target.exists() and not args.overwrite:
                skipped.append(str(target))
                if args.verbose:
                    print(f"skip (exists): {target}")
                continue

            content = pick_template(rel_path)

            # write the file (overwrite or create)
            with target.open("w", encoding="utf-8", newline="\n") as fh:
                fh.write(content)

            created.append(str(target))
            if args.verbose:
                print(f"created: {target}")

        except Exception as e:
            failed.append((str(target), str(e)))
            print(f"ERROR: {target} -> {e}", file=sys.stderr)

    # summary
    print("\nSummary:")
    print(f"  created: {len(created)}")
    print(f"  skipped (already existed): {len(skipped)}")
    print(f"  failed: {len(failed)}")
    if args.verbose and created:
        print("\nCreated files:")
        for c in created:
            print("  ", c)
    if failed:
        print("\nFailures:")
        for t, err in failed:
            print("  ", t, "->", err)


if __name__ == "__main__":
    main()
